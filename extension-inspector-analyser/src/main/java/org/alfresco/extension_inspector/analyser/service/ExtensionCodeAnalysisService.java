/*
 * Copyright 2015-2020 Alfresco Software, Ltd.  All rights reserved.
 *
 * License rights for this program may be obtained from Alfresco Software, Ltd.
 * pursuant to a written agreement and any use of this program without such an
 * agreement is prohibited.
 */
package org.alfresco.extension_inspector.analyser.service;

import static java.util.Collections.emptySet;
import static java.util.stream.Collectors.toUnmodifiableMap;
import static java.util.stream.Collectors.toUnmodifiableSet;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.alfresco.extension_inspector.analyser.util.BytecodeReader;
import org.alfresco.extension_inspector.analyser.util.DependencyVisitor;
import org.objectweb.asm.ClassReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * This Bean caches extension (amp/jar) information generated by parsing
 * the actual Java bytecode in the extension artifact.
 * <p/>
 * The extension is static/immutable, therefore we can afford to process
 * information about it only once and cache the result for subsequent uses.
 * <p/>
 * Some Checkers need the same info about an Extension. But even if
 * they need different info, they'll still need it multiple times (once
 * for each WAR version).
 *
 * @author Cezar Leahu
 * @author Lucian Tuca
 */
@Component
public class ExtensionCodeAnalysisService
{
    private static final Logger LOGGER = LoggerFactory.getLogger(ExtensionCodeAnalysisService.class);

    @Autowired
    private ConfigService configService;
    @Autowired
    private BytecodeReader bytecodeReader;

    private Map<String, Set<String>> dependenciesPerClass;
    private Set<String> allDependencies;

    /**
     * Retrieve a map of (class_name -> {dependencies}} for the extension.
     * This is achieved by actually parsing all the Java bytecode in the artifact.
     * <p/>
     * The format of the dependency/class entries (ids) is: "/package/path/ClassName.class"
     * (both the returned map Keys & the Set values)
     *
     * @return a map of all the classes in the extension, with their dependencies.
     */
    public Map<String, Set<String>> retrieveDependenciesPerClass()
    {
        if (dependenciesPerClass == null)
        {
            // each class can have multiple definitions (different jars), hence a list of bytecode instances per class
            final Map<String, List<byte[]>> bytecodePerClass = bytecodeReader.readArtifact(
                configService.getExtensionPath());

            dependenciesPerClass = bytecodePerClass
                .entrySet()
                .stream()
                .collect(toUnmodifiableMap(
                    Map.Entry::getKey,
                    e -> e.getValue()
                          .stream()
                          .map(v -> compileClassDependenciesFromBytecode(e.getKey(), v))
                          .flatMap(Collection::stream) // due to multiple instances of the same class
                          .collect(toUnmodifiableSet())
                ));
        }
        return dependenciesPerClass;
    }

    /**
     * Retrieve a set of all the dependencies of an extension.
     * This is achieved by actually parsing all the Java bytecode in the artifact.
     * <p/>
     * The format of the dependency/class entries is: "/package/path/ClassName.class"
     *
     * @return
     */
    public Set<String> retrieveAllDependencies()
    {
        if (allDependencies == null)
        {
            allDependencies = retrieveDependenciesPerClass()
                .values()
                .stream()
                .flatMap(Collection::stream)
                .collect(toUnmodifiableSet());
        }
        return allDependencies;
    }

    /**
     * For a given .class file provided as byte[] this method finds all the classes this class uses.
     *
     * @param classData the .class file as byte[]
     * @return a {@link Set} of the used classes
     */
    static Set<String> compileClassDependenciesFromBytecode(final String name, final byte[] classData)
    {
        try
        {
            final DependencyVisitor visitor = new DependencyVisitor();
            final ClassReader reader = new ClassReader(classData);
            reader.accept(visitor, ClassReader.EXPAND_FRAMES);
            visitor.visitEnd();

            return visitor
                .getClasses()
                .stream()
                .filter(s -> !s.startsWith("java/")) // strip JDK dependencies
                .map(s -> "/" + s + ".class") // change it to the Inventory Report format
                .collect(toUnmodifiableSet());
        }
        catch (UnsupportedOperationException e)
        {
            LOGGER.warn("Failed to parse bytecode for " + name + ": " + e.getMessage());
            return emptySet();
        }
    }
}
